package edu.arizona.sista.odin.impl

import edu.arizona.sista.struct.Interval
import edu.arizona.sista.processors.Document
import edu.arizona.sista.odin._

trait Extractor {
  def name: String
  def labels: Seq[String]
  def label: String = labels.head  // the first label in the sequence is the default
  def priority: Priority
  def keep: Boolean  // should we keep mentions generated by this extractor?
  def action: ReflectedAction

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention]

  def findAllIn(doc: Document, state: State): Seq[Mention] = for {
    i <- 0 until doc.sentences.size
    m <- findAllIn(i, doc, state)
  } yield m

  def startsAt: Int = priority match {
    case ExactPriority(i) => i
    case IntervalPriority(start, end) => start
    case InfiniteIntervalPriority(start) => start
  }
}

class TokenExtractor(
    val name: String,
    val labels: Seq[String],
    val priority: Priority,
    val keep: Boolean,
    val action: ReflectedAction,
    val pattern: TokenPattern
) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = {
    val results = pattern.findAllIn(sent, doc, state)
    val mentions = for (r <- results) yield mkMention(r, sent, doc)
    action(mentions, state)
  }

  def mkMention(r: TokenPattern.Result, sent: Int, doc: Document): Mention =
    r.groups.keys find (_ equalsIgnoreCase "trigger") match {
      case Some(triggerKey) =>
        // result has a trigger, create an EventMention
        val trigger = new TextBoundMention(labels, r.groups(triggerKey), sent, doc, keep, name)
        val groups = r.groups - triggerKey transform {
          (name, interval) => Seq(new TextBoundMention(labels, interval, sent, doc, keep, name))
        }
        val mentions = r.mentions.transform((name, mention) => Seq(mention))
        val args = groups ++ mentions
        new EventMention(labels, trigger, args, sent, doc, keep, name)
      case None if r.groups.nonEmpty || r.mentions.nonEmpty =>
        // result has arguments and no trigger, create a RelationMention
        val groups = r.groups transform {
          (name, interval) => Seq(new TextBoundMention(labels, interval, sent, doc, keep, name))
        }
        val mentions = r.mentions.transform((name, mention) => Seq(mention))
        val args = groups ++ mentions
        new RelationMention(labels, args, sent, doc, keep, name)
      case None =>
        // result has no arguments, create a TextBoundMention
        new TextBoundMention(labels, r.interval, sent, doc, keep, name)
    }
}

class DependencyExtractor(
    val name: String,
    val labels: Seq[String],
    val priority: Priority,
    val keep: Boolean,
    val action: ReflectedAction,
    val pattern: DependencyPattern
) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = {
    val mentions = pattern.getMentions(sent, doc, state, labels, keep, name)
    action(mentions, state)
  }
}
